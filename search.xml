<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Mysql的EXPLAIN</title>
    <url>/2021/02/19/Mysql%E7%9A%84EXPLAIN%E5%92%8Csql%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h3 id="EXPLAIN中的列"><a href="#EXPLAIN中的列" class="headerlink" title="EXPLAIN中的列"></a>EXPLAIN中的列</h3><p>id(列的编号)</p>
<p>select_type(对应的行是简单还是复杂查询)<br>    SUBQUERY<br>        不在from子句中的自查询<br>    DERIVED<br>        在from子句中的查询<br>    UNION<br>        在union中的第二个和随后的select查询<br>    UNION RESULT<br>        从union的匿名临时表检索结果的select</p>
<p>table(对应行在访问哪个表)</p>
<p>type(关联类型)<br>    ALL<br>        全表扫描<br>    index<br>        全表扫描，只是按照索引次序进行而不是行，避免了排序，缺点是承担按照索引次序读取整个表的开销，如果Extra列显示useing index 则说明在使用覆盖索引，只扫描索引的数据，开销要小很多<br>    range<br>        有限制的索引扫描，范围扫描数据<br>    ref<br>        索引查找，返回所有匹配某个单个值的行，但是可能会找到多个符合条件的行，当使用非唯一索引，或唯一索引的非唯一性前缀才会发生<br>    eq_ref<br>        使用索引或唯一索引<br>    const,system<br>        使用常量的时候，例如将某一行的主键放入where子句中的方式来选取此行的主键<br>    NULL<br>        用不着访问表或者索引</p>
<p>possiable_keys(可以使用哪些索引)</p>
<p>key(使用了哪个索引，如果没有出现在possiable_keys中，可能使用了覆盖索引)</p>
<p>key_len（索引字节数，索引字段中可能的最大长度，而不是实际的）</p>
<p>ref（展示了之前的表在key列表记录的索引）</p>
<p>rows（找到所需行而要读取的行数）</p>
<p>extra<br>    Using index<br>        Mysql使用覆盖索引<br>    Using where<br>        存储引擎检索行后过滤，暗示查询受益于不同的索引<br>    Using temporary<br>        对查询结果排序时使用临时表<br>    Using filesort<br>        对结果进行外部索引排序，而不是按索引次序从表中读<br>    Range checked for each record(index map: N)<br>        没有很好的使用索引，新的索引将在连接的每一行上重新估算，N是显示在possiable_keys中的索引的位图，并且都是冗余的</p>
<p>filtered（表里符合条件的记录数的百分比做的悲观估算）</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql的sql优化</title>
    <url>/2021/02/19/Mysql%E7%9A%84sql%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h3 id="Sql优化"><a href="#Sql优化" class="headerlink" title="Sql优化"></a>Sql优化</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 这种比较慢 因为字段无索引要全表扫描</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">min</span>(a.id) <span class="keyword">from</span> yh_user a <span class="keyword">where</span> a.settle_object_name <span class="operator">=</span> <span class="string">&#x27;于林宏&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 这种的话，因为主键是按照大小顺序排列的，所以插叙到第一条的时候就停止了</span><br><span class="line"><span class="keyword">select</span> a.id <span class="keyword">from</span> yh_user a use INDEX(<span class="keyword">PRIMARY</span>) <span class="keyword">where</span> a.settle_object_name <span class="operator">=</span> <span class="string">&#x27;于林宏&#x27;</span> LIMIT <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"># 这种没有下面的快</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> yh_customer a <span class="keyword">where</span> a.id <span class="operator">&gt;</span><span class="number">6</span>;</span><br><span class="line">#这种会更快。 因为当不带任何条件的count的时候mysql可以利用存储引擎的特性直接获得这个值。从而减少查询的行数,只适用于特定场景</span><br><span class="line"><span class="keyword">select</span> (<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> yh_customer) <span class="operator">-</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> yh_customer a <span class="keyword">where</span> a.id <span class="operator">&lt;=</span> <span class="number">6</span>;</span><br><span class="line"># 快速 精确 简单 永远要舍弃一个</span><br><span class="line"></span><br><span class="line">#深度分页 <span class="number">40</span>s</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> yh_user a <span class="keyword">order</span> <span class="keyword">by</span> a.gmt_create,id limit <span class="number">200000</span>,<span class="number">1</span> ;</span><br><span class="line">#不到<span class="number">1</span>s。 扫描更少的数据，获取访问的数据之后再关联 </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> yh_user b <span class="keyword">INNER</span> <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> id <span class="keyword">from</span> yh_user <span class="keyword">order</span> <span class="keyword">by</span> gmt_create,id limit <span class="number">200000</span>,<span class="number">1</span>) <span class="keyword">as</span> lim <span class="keyword">using</span>(id);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>java1.8是如何自动释放直接内存的</title>
    <url>/2021/09/27/Tcp/</url>
    <content><![CDATA[<h1 id="java1-8是如何自动释放直接内存的"><a href="#java1-8是如何自动释放直接内存的" class="headerlink" title="java1.8是如何自动释放直接内存的"></a>java1.8是如何自动释放直接内存的</h1><h3 id="如何设置直接内存大小"><a href="#如何设置直接内存大小" class="headerlink" title="如何设置直接内存大小"></a>如何设置直接内存大小</h3><p>-XX:MaxDirectMemorySize参数来指定。直接内存和jvm的空间划分没有关系。</p>
<blockquote>
<ul>
<li>如果不指定默认和-Xmx大小一致。 【网上查到的结论】</li>
</ul>
</blockquote>
<h3 id="如何申请直接内存"><a href="#如何申请直接内存" class="headerlink" title="如何申请直接内存"></a>如何申请直接内存</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用ByteBuffer申请内存空间，内部new了一个DirectByteBuffer</span></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure>
<h3 id="如何自动释放内存"><a href="#如何自动释放内存" class="headerlink" title="如何自动释放内存"></a>如何自动释放内存</h3><blockquote>
<ul>
<li>首先创建Cleaner，创建Cleaner的时候传入了Deallocator对象，Deallocator的run方法中unsafe.freeMemory(address);释放内存。</li>
<li>在创建Cleaner之后，会把新new出来的Cleaner加入到链表之中</li>
<li>因为Cleaner对象继承了PhantomReference引用。PhantomReference又继承了Reference。</li>
<li>Reference在静态代码块中new了一个守护线程，这个线程的run方法中写了一个死循环，调用tryHandlePending(true);方法</li>
<li>在处理tryHandlePending的时候，如果Cleaner不是null，就调用之前的run方法，释放内存空间。</li>
</ul>
</blockquote>
<p><img src="/images/pasted-0.png" alt="upload successful"></p>
<p><img src="/images/pasted-1.png" alt="upload successful"></p>
<p><img src="/images/pasted-2.png" alt="upload successful"></p>
<p><img src="/images/pasted-3.png" alt="upload successful"></p>
<p><img src="/images/pasted-4.png" alt="upload successful"></p>
<p><img src="/images/pasted-5.png" alt="upload successful"></p>
<p><img src="/images/pasted-6.png" alt="upload successful"></p>
]]></content>
      <tags>
        <tag>direct memory</tag>
      </tags>
  </entry>
  <entry>
    <title>@Autowired原理</title>
    <url>/2021/01/14/@Autowired%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>@Autowired的实现是依靠AutowiredAnnotationBeanPostProcessor来实现的</p>
</blockquote>
<p>本文使用的spring-boot 2.4.1版本</p>
<h5 id="问题一：AutowiredAnnotationBeanPostProcessor是何时被加到容器中的？"><a href="#问题一：AutowiredAnnotationBeanPostProcessor是何时被加到容器中的？" class="headerlink" title="问题一：AutowiredAnnotationBeanPostProcessor是何时被加到容器中的？"></a>问题一：<strong>AutowiredAnnotationBeanPostProcessor是何时被加到容器中的？</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SpringApplication中的此方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">	StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">	stopWatch.start();</span><br><span class="line">	DefaultBootstrapContext bootstrapContext = createBootstrapContext();</span><br><span class="line">	ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">	configureHeadlessProperty();</span><br><span class="line">	SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">	listeners.starting(bootstrapContext, <span class="keyword">this</span>.mainApplicationClass);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span><br><span class="line">		ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments);</span><br><span class="line">		configureIgnoreBeanInfo(environment);</span><br><span class="line">		Banner printedBanner = printBanner(environment);</span><br><span class="line">           <span class="comment">// 这一步创建容器的时候  开始创建AutowiredAnnotationBeanPostProcessor的beanDefinition</span></span><br><span class="line">		context = createApplicationContext();</span><br><span class="line">		context.setApplicationStartup(<span class="keyword">this</span>.applicationStartup);</span><br><span class="line">		prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">		refreshContext(context);</span><br><span class="line">		afterRefresh(context, applicationArguments);</span><br><span class="line">		stopWatch.stop();</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">			<span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">		&#125;</span><br><span class="line">		listeners.started(context);</span><br><span class="line">		callRunners(context, applicationArguments);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableApplicationContext <span class="title">createApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.applicationContextFactory.create(<span class="keyword">this</span>.webApplicationType);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContextFactory DEFAULT = (webApplicationType) -&gt; &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">switch</span> (webApplicationType) &#123;</span><br><span class="line">			<span class="keyword">case</span> SERVLET:</span><br><span class="line">            <span class="comment">/* 会选择这一个上下文  webApplicationType是之前在new SpringApplication的时候 由WebApplicationType.deduceFromClasspath()决定的 */</span></span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> AnnotationConfigServletWebServerApplicationContext();</span><br><span class="line">			<span class="keyword">case</span> REACTIVE:</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> AnnotationConfigReactiveWebServerApplicationContext();</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unable create a default ApplicationContext instance, &quot;</span></span><br><span class="line">					+ <span class="string">&quot;you may need a custom ApplicationContextFactory&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigServletWebServerApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 通过这个方法获取AutowiredAnnotationBeanPostProcessor的bean definiton</span></span><br><span class="line">	<span class="keyword">this</span>.reader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">this</span>.scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotatedBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>(registry, getOrCreateEnvironment(registry));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotatedBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry, Environment environment)</span> </span>&#123;</span><br><span class="line">	Assert.notNull(registry, <span class="string">&quot;BeanDefinitionRegistry must not be null&quot;</span>);</span><br><span class="line">	Assert.notNull(environment, <span class="string">&quot;Environment must not be null&quot;</span>);</span><br><span class="line">	<span class="keyword">this</span>.registry = registry;</span><br><span class="line">	<span class="keyword">this</span>.conditionEvaluator = <span class="keyword">new</span> ConditionEvaluator(registry, environment, <span class="keyword">null</span>);</span><br><span class="line">	<span class="comment">// 这个方法读取</span></span><br><span class="line">       AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="keyword">this</span>.registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  这个方法要注意的是，AutowiredAnnotationBeanPostProcessor这个bean指定了beanName，为</span></span><br><span class="line"><span class="comment">  org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	</span><br><span class="line">		<span class="keyword">if</span> (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">			RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);</span><br><span class="line">			def.setSource(source);</span><br><span class="line">			beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>以上beanDefinition就解析成功了，第二步就是注册这个后置处理器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AbstractApplicationContext的</span></span><br><span class="line">   <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">   <span class="comment">//这个方法把AutowiredAnnotationBeanPostProcessor注入</span></span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br></pre></td></tr></table></figure>
<h5 id="问题二：AutowiredAnnotationBeanPostProcessor是如何生效的？"><a href="#问题二：AutowiredAnnotationBeanPostProcessor是如何生效的？" class="headerlink" title="问题二：AutowiredAnnotationBeanPostProcessor是如何生效的？"></a>问题二：<strong>AutowiredAnnotationBeanPostProcessor是如何生效的？</strong></h5><blockquote>
<p>AbstractAutowireCapableBeanFactory的doCreateBean方法<br>有两个概念，一个是实例化，一个是初始化.</p>
<ul>
<li>实例化就是new出来这个对象，开辟内存</li>
<li>初始化就是为这个bean填充所有的属性值</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">		<span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">                </span><br><span class="line"> <span class="comment">// 这一段就是为了初始化bean，找出这个bean上需要注入哪些值</span></span><br><span class="line">					applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">							<span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">				&#125;</span><br><span class="line">				mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">		<span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">		<span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">				isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">		<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line">						<span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Initialize the bean instance.</span></span><br><span class="line">		Object exposedObject = bean;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这个就是初始化 Initialize 为了填充属性</span></span><br><span class="line">			populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">			exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历MergedBeanDefinitionPostProcessor的一些后置处理器，其中有一个就是</span></span><br><span class="line"><span class="comment">//AutowiredAnnotationBeanPostProcessor</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyMergedBeanDefinitionPostProcessors</span><span class="params">(RootBeanDefinition mbd, Class&lt;?&gt; beanType, String beanName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (MergedBeanDefinitionPostProcessor processor : getBeanPostProcessorCache().mergedDefinition) &#123;</span><br><span class="line">			processor.postProcessMergedBeanDefinition(mbd, beanType, beanName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> </span>&#123;          </span><br><span class="line">   <span class="comment">//这个就是寻找被@Autowired注解标注的属性</span></span><br><span class="line">   <span class="comment">// 找到之后被放到了injectionMetadataCache中 以供注入</span></span><br><span class="line">	InjectionMetadata metadata = findAutowiringMetadata(beanName, beanType, <span class="keyword">null</span>);</span><br><span class="line">	metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行完了之后，就会走到之前提到的初始化方法populateBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PropertyDescriptor[] filteredPds = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">			<span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">				pvs = mbd.getPropertyValues();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) &#123;</span><br><span class="line">            <span class="comment">// 这里开始注入属性</span></span><br><span class="line">				PropertyValues pvsToUse = bp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line">				<span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">if</span> (filteredPds == <span class="keyword">null</span>) &#123;</span><br><span class="line">						filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">					&#125;</span><br><span class="line">					pvsToUse = bp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">					<span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">						<span class="keyword">return</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				pvs = pvsToUse;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">		<span class="comment">// AutowiredAnnotationBeanPostProcessor的inject方法</span></span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 解决找到需要注入的对象</span></span><br><span class="line">				value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedDependencyException(<span class="keyword">null</span>, beanName, <span class="keyword">new</span> InjectionPoint(field), ex);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!<span class="keyword">this</span>.cached) &#123;</span><br><span class="line">					Object cachedFieldValue = <span class="keyword">null</span>;</span><br><span class="line">					<span class="keyword">if</span> (value != <span class="keyword">null</span> || <span class="keyword">this</span>.required) &#123;</span><br><span class="line">						cachedFieldValue = desc;</span><br><span class="line">						registerDependentBeans(beanName, autowiredBeanNames);</span><br><span class="line">						<span class="keyword">if</span> (autowiredBeanNames.size() == <span class="number">1</span>) &#123;</span><br><span class="line">							String autowiredBeanName = autowiredBeanNames.iterator().next();</span><br><span class="line">							<span class="keyword">if</span> (beanFactory.containsBean(autowiredBeanName) &amp;&amp;</span><br><span class="line">									beanFactory.isTypeMatch(autowiredBeanName, field.getType())) &#123;</span><br><span class="line">								cachedFieldValue = <span class="keyword">new</span> ShortcutDependencyDescriptor(</span><br><span class="line">										desc, autowiredBeanName, field.getType());</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">this</span>.cachedFieldValue = cachedFieldValue;</span><br><span class="line">					<span class="keyword">this</span>.cached = <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 通过反射完成注入</span></span><br><span class="line">			ReflectionUtils.makeAccessible(field);</span><br><span class="line">			field.set(bean, value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
</search>
